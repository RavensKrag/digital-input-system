trial 1:
	use buffer to gather input strings
	
	data:
		tap
		["u↓", "u↑"]
		hold
		["u↓", "u↑"]
		sequence
		["a↓", "a↑", "o↓", "o↑", "e↓", "e↑", "u↓", "u↑"]
		sequence hold end
		["a↓", "a↑", "o↓", "o↑", "e↓", "e↑", "u↓", "u↑"]
		arpeggiated chord
		["a↓", "o↓", "e↓", "u↓", "a↑", "o↑", "e↑", "u↑"]
		chord
		["a↓", "o↓", "e↓", "u↓", "a↑", "o↑", "e↑", "u↑"]
		timed sequence
		["a↓", "a↑", "o↓", "o↑", "e↓", "e↑", "u↓", "u↑"]


	result: need time deltas



tap
	down
hold
	down -- (interval) -- up
	
	check that interval exceeds expected threshold
	anything could happen in the interval
sequence
	


TODO: Separate into event start and event end sequences
inputs with no separate up sequence can not be held
they fire 

tap
	[
		Input.new(Gosu::KbA, :down,	0),
		
		
		
		
		Input.new(Gosu::KbA, :up,	20),
	]
	
	short interval

hold
	[
		Input.new(Gosu::KbA, :down,	0),
		
		
		
		Input.new(Gosu::KbA, :up,	200),
	]
	
	long interval
	
sequence
	[
		Input.new(Gosu::KbA, :down,	0+300*0),
		Input.new(Gosu::KbA, :up,	200+300*0),
		
		Input.new(Gosu::KbO, :down,	0+300*1),
		Input.new(Gosu::KbO, :up,	200+300*1),
		
		Input.new(Gosu::KbE, :down,	0+300*2),
		
		-- potential hold (if there's a hold, break on the last key, otherwise just end)
		
		Input.new(Gosu::KbE, :up,	200+300*2),
	]
roll
	[
		Input.new(Gosu::KbA, :down,	0),
		Input.new(Gosu::KbA, :up,	150),
		
		Input.new(Gosu::KbO, :down,	100),
		Input.new(Gosu::KbO, :up,	250),
		
		Input.new(Gosu::KbE, :down,	200),
		
		-- potential hold (if there's a hold, break on the last key, otherwise just end)
		
		Input.new(Gosu::KbE, :up,	350)
	]
arp chord
	[
		Input.new(Gosu::KbA, :down,	0),
		Input.new(Gosu::KbO, :down,	100),
		Input.new(Gosu::KbE, :down,	200),
		
		
		
		
		Input.new(Gosu::KbA, :up,	500),
		Input.new(Gosu::KbO, :up,	500),
		Input.new(Gosu::KbE, :up,	500),
	]
chord
	[
		Input.new(Gosu::KbA, :down,	0),
		Input.new(Gosu::KbO, :down,	0),
		Input.new(Gosu::KbE, :down,	0),
		
		
		
		
		Input.new(Gosu::KbA, :up,	500),
		Input.new(Gosu::KbO, :up,	500),
		Input.new(Gosu::KbE, :up,	500),
	]


above sequences seem pretty easy to create a nice clean interface for
the "sequence" type is different though,
because the whole point is being able to list specific times between button presses


how do you find a down event?
	find the sequences needed to trigger the even
but when you want to fight an up event
	you need to look for both the down and the up sequences back to back
	
	NO
	
	if you do that, then holding down a sequence, and then hitting bunch of other keys
		which would clease a large chunk of the buffer
	would prevent detecting of an up event


maybe the sequence requested to be searched by the event tracker should change
from the button down sequence to the button up sequence
depending on the state of the event tracker?