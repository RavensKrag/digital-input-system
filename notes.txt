trial 1:
	use buffer to gather input strings
	
	data:
		tap
		["u↓", "u↑"]
		hold
		["u↓", "u↑"]
		sequence
		["a↓", "a↑", "o↓", "o↑", "e↓", "e↑", "u↓", "u↑"]
		sequence hold end
		["a↓", "a↑", "o↓", "o↑", "e↓", "e↑", "u↓", "u↑"]
		arpeggiated chord
		["a↓", "o↓", "e↓", "u↓", "a↑", "o↑", "e↑", "u↑"]
		chord
		["a↓", "o↓", "e↓", "u↓", "a↑", "o↑", "e↑", "u↑"]
		timed sequence
		["a↓", "a↑", "o↓", "o↑", "e↓", "e↑", "u↓", "u↑"]


	result: need time deltas



tap
	down
hold
	down -- (interval) -- up
	
	check that interval exceeds expected threshold
	anything could happen in the interval
sequence
	


TODO: Separate into event start and event end sequences
inputs with no separate up sequence can not be held
they fire 

tap
	[
		Input.new(Gosu::KbA, :down,	0),
		
		
		
		
		Input.new(Gosu::KbA, :up,	20),
	]
	
	short interval

hold
	[
		Input.new(Gosu::KbA, :down,	0),
		
		
		
		Input.new(Gosu::KbA, :up,	200),
	]
	
	long interval
	
sequence
	[
		Input.new(Gosu::KbA, :down,	0+300*0),
		Input.new(Gosu::KbA, :up,	200+300*0),
		
		Input.new(Gosu::KbO, :down,	0+300*1),
		Input.new(Gosu::KbO, :up,	200+300*1),
		
		Input.new(Gosu::KbE, :down,	0+300*2),
		
		-- potential hold (if there's a hold, break on the last key, otherwise just end)
		
		Input.new(Gosu::KbE, :up,	200+300*2),
	]
roll
	[
		Input.new(Gosu::KbA, :down,	0),
		Input.new(Gosu::KbA, :up,	150),
		
		Input.new(Gosu::KbO, :down,	100),
		Input.new(Gosu::KbO, :up,	250),
		
		Input.new(Gosu::KbE, :down,	200),
		
		-- potential hold (if there's a hold, break on the last key, otherwise just end)
		
		Input.new(Gosu::KbE, :up,	350)
	]
arp chord
	[
		Input.new(Gosu::KbA, :down,	0),
		Input.new(Gosu::KbO, :down,	100),
		Input.new(Gosu::KbE, :down,	200),
		
		
		
		
		Input.new(Gosu::KbA, :up,	500),
		Input.new(Gosu::KbO, :up,	500),
		Input.new(Gosu::KbE, :up,	500),
	]
chord
	[
		Input.new(Gosu::KbA, :down,	0),
		Input.new(Gosu::KbO, :down,	0),
		Input.new(Gosu::KbE, :down,	0),
		
		
		
		
		Input.new(Gosu::KbA, :up,	500),
		Input.new(Gosu::KbO, :up,	500),
		Input.new(Gosu::KbE, :up,	500),
	]


above sequences seem pretty easy to create a nice clean interface for
the "sequence" type is different though,
because the whole point is being able to list specific times between button presses


how do you find a down event?
	find the sequences needed to trigger the even
but when you want to fight an up event
	you need to look for both the down and the up sequences back to back
	
	NO
	
	if you do that, then holding down a sequence, and then hitting bunch of other keys
		which would clease a large chunk of the buffer
	would prevent detecting of an up event


maybe the sequence requested to be searched by the event tracker should change
from the button down sequence to the button up sequence
depending on the state of the event tracker?


question:
	want to detct
		chord(ABC) -> chord(BCD)
	actual input is
		chord(ABC) -> B -> chord(BCD)
	but the chords hit at expected times
	is the input valid, or not, and why?
answer:
	???




accelerator(shift) + click
	accelerators are OR detection, rather than the AND detection usually used on :press test
	well, not OR, because that would fire on any
	rather, non-sequential AND
	
	--- does it matter at all what the order is?
	when you talk about accelerators, it feels like (example) shift is auxilerry, and click is main
	but the whole accelerator pattern only fires when the whole thing is compelete
	so does it matter what order you look for these things?
	
	AND relations can short-circuit if only one of the things is false
	is there a particular order to accelerator patterns that will help with short-circuiting?
	
	
	POSSIBLE IMPLEMENTATION
	
	put all evens in a hash
	when you match any event in the hash
	take the value, and set it to true
	run Hash#all? to see if :press event fires
	
	-> gets complicated when you have Sequences as triggers, rather than simple events




complex(a, b, c) + simple
analogous to
[a, b, c] + d
might just be easier to do
[a, b, c] + [d]
and be done with it
not sure though if the user of the library should be forced to do that conversion manually

though... for numbers, auto-conversion is standard


if you wrap like this, it becomes just a matter of checking if all sequences are active






---------------------------------------------
---- how should edge trigger be handled? ----
---------------------------------------------
Strategy A
	tick		press			hold only triggers if the button is held for more than one tick
	tick		hold			
	tick		hold			
	
	
	or

Strategy B	
	tick		press			hold triggers after the edge transition
				hold			
	tick		hold			
	tick		hold			





complex events can't fire press until next tick
because #trigger_press? doesn't actually fire transition
it basically just queues the transition

so the transition has not taken effect when the complex is evaluated
it WILL have taken effect on the next input tick

thus, you have the perceived off-by-one error



this is a problem with refusing to transition,
in order to prevent callbacks
	perhaps solution is to fully separate transitions from whether or not callbacks fire?


solution:
	Use Strategy A for handeling edge triggers as seen above
	this is accomplished by spliting state machine from 2 states into 4 states
	also, running callbacks only on #update, rather than immediately after Event is processed
